## Feature de autenticacion
```
nest generate resource autenticacion
```

## Metodo para hashear password

En el archivo `src/autenticacion/autenticacion.service.ts`
```ts
import * as crypto from 'crypto';

    protected hashPassword(password: string): string {
        return crypto.createHash('sha256').update(password).digest('hex');
    }
```

## Creacion de DTO para login
En el archivo `src/autenticacion/dto/login-autenticacion.dto.ts`
```ts
import { ApiProperty } from "@nestjs/swagger";
import { IsNotEmpty, IsString } from "class-validator";

export class LoginDto {
    @ApiProperty({
        description: 'Usuario para login',
        example: 'admin'
    })
    @IsString()
    @IsNotEmpty({ message: '($property) Es requerido' })
    public usu_usuario: string;

    @ApiProperty({
        description: 'Contraseña del usuario',
        example: 'P1secreto%ty'
    })
    @IsString()
    @IsNotEmpty({ message: '($property) Es requerido' })
    public usu_password: string;
}
```


## Login usando TyORM
En el archivo `src/autenticacion/autenticacion.service.ts`
```ts
    constructor(
        @InjectRepository(Usuarios)
        private usuarioRepository: Repository<Usuarios>,
        private dataSource: DataSource,
    ) { }
```

```ts
    async loginWithORM(LoginDto: LoginDto): Promise<Usuarios | null> {

        const hashedPassword = this.hashPassword(LoginDto.usu_password);

        const estado = new Estados()
        estado.est_id = 1

        const usuario = await this.usuarioRepository.findOne({
            where: {
                usu_usuario: LoginDto.usu_usuario,
                usu_password: hashedPassword,
                est_: estado,
                usu_fecha_vigencia: MoreThan(new Date().toISOString().split('T')[0])
            },
            select: {
                usu_id: true,
                usu_usuario: true,
                per_: {
                    per_id: true,
                    per_nombre_completo: true,
                    per_documento_identidad: true
                },
                est_: {
                    est_id: true,
                    est_nombre: true,
                }
            },
            relations: ['per_', 'est_']
        });

        if (!usuario) throwError(401, 'USUARIO NO ENCOTNRADO')

        return usuario;
    }
```

```ts
  // Método con SQL nativo
    async loginWithSQL(LoginDto: LoginDto): Promise<Usuarios | null> {
        const hashedPassword = this.hashPassword(LoginDto.usu_password);
        const today = new Date().toISOString().split('T')[0];

        const query = `
      SELECT 
        u.usu_id,
        u.usu_usuario,
        u.per_id,
        u.est_id,
        e.est_nombre, 
        p.per_documento_identidad,
        p.per_nombre_completo
      FROM autenticacion.usuarios AS u
      INNER JOIN parametricas.estados AS e ON e.est_id = u.est_id
      INNER JOIN reservas.personas AS p ON p.per_id = u.per_id
      WHERE TRUE
      AND u.usu_usuario = $1 
      AND u.usu_password = $2
      AND (u.usu_fecha_vigencia IS NULL OR u.usu_fecha_vigencia > $3)
      AND u.est_id = 1
      LIMIT 1
    `;

        let usuario = await this.dataSource.query(query, [
            LoginDto.usu_usuario,
            hashedPassword,
            today
        ]);

        usuario = usuario[0]
        if (!usuario) throwError(401, 'USUARIO NO ENCOTNRADO')

        return usuario;
    }
```

## Titulo
En el archivo `src/autenticacion/autenticacion.controller.ts`
```ts
  @Post('login-typeorm')
  loginWithORM(@Body() LoginDto: LoginDto) {
    return this.autenticacionService.loginWithORM(LoginDto);
  }

  @Post('login-sql')
  loginWithSQL(@Body() LoginDto: LoginDto) {
    return this.autenticacionService.loginWithSQL(LoginDto);
  }
```

## Token JWT

![alt text](https://cdn.sanity.io/images/3jwyzebk/production/1d7ccf20c8814876a8e3cc4b94d3ea6c4521ef61-1584x325.png?auto=format&fit=max&w=1920&q=75)

Un JWT (JSON Web Token) es un estándar abierto (RFC 7519) para crear tokens seguros que transmiten información entre dos partes

![alt text](https://cdn.sanity.io/images/3jwyzebk/production/c098fa07deca1062e013d92cabba4ba7ec7e7f19-1584x988.png?auto=format&fit=max&w=1920&q=75)


## Instalacion de dependencias.

```
npm install @nestjs/jwt @nestjs/passport passport passport-jwt
npm install -D @types/passport-jwt
```

## Agregar variables de entorno
```
JWT_SECRET=tu_clave_secreta_compleja_aqui
JWT_EXPIRE=24h
```
## Crear configuracion JWT 
En el archivo `src\autenticacion\config\jwt.config.ts`
```ts
export const jwtConfig = {
    secret: process.env.JWT_SECRET || 'Clav3&&S3cret@',
    signOptions: {
        expiresIn: process.env.JWT_EXPIRE || '2h'
    },
    verifyOptions: {
        ignoreExpiration: false
    }
}
```

## Crear estrategia JWT 
En el archivo `src/strategies/jwt.strategy.ts`
```ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { jwtConfig } from 'src/autenticacion/config/jwt.config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: jwtConfig.verifyOptions.ignoreExpiration,
      secretOrKey: jwtConfig.secret,
    });
  }

  async validate(payload: any) {
    return {
      usu_id: payload.sub,
      usu_usuario: payload.username,
      per_id: payload.per_id,
      est_id: payload.est_id,
      documento: payload.documento,
      nombre: payload.nombre
    };
  }
}
```

## Configuracion del modulo JWT 
En el archivo `src\autenticacion\autenticacion.module.ts`
```ts
import { Module } from '@nestjs/common';
import { AutenticacionService } from './autenticacion.service';
import { AutenticacionController } from './autenticacion.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { entities } from 'src/entities/Index';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { JwtStrategy } from 'src/strategies/jwt.strategy';
import { jwtConfig } from './config/jwt.config';

@Module({
  imports: [
    TypeOrmModule.forFeature(entities),
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.register(jwtConfig)
  ],
  controllers: [AutenticacionController],
  providers: [AutenticacionService, JwtStrategy],
  exports: [JwtModule, PassportModule],
})
export class AutenticacionModule { }

```

## Modificar el servicio de autenticacion
En el archivo `src/autenticacion/autenticacion.service.ts`
```ts
        // Generar token JWT
        const payload = {
            sub: usuario.usu_id,
            username: usuario.usu_usuario,
            per_id: usuario.per_id,
            est_id: usuario.est_id,
            documento: usuario.per_documento_identidad,
            nombre: usuario.per_nombre_completo
        };

        const accessToken = this.jwtService.sign(payload, jwtConfig.signOptions);

        return {
            usuario: {
                usu_id: usuario.usu_id,
                usu_usuario: usuario.usu_usuario,
                per_id: usuario.per_id,
                est_id: usuario.est_id,
                est_nombre: usuario.est_nombre,
                per_documento_identidad: usuario.per_documento_identidad,
                per_nombre_completo: usuario.per_nombre_completo
            },
            token: 'Bearer' + accessToken 
        };

```

## Adicion de middleware

### Creacion de middleware
```
nest generate middleware middlewares/autenticacion
```

En el archivo `src\middlewares\autenticacion\autenticacion.middleware.ts`
```ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class JwtAuthMiddleware implements NestMiddleware {
  constructor(private readonly jwtService: JwtService) {}

  async use(req: Request, res: Response, next: NextFunction) {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return res.status(401).json({ message: 'Token no proporcionado' });
    }

    const [bearer, token] = authHeader.split(' ');

    if (bearer !== 'Bearer' || !token) {
      return res.status(401).json({ message: 'Formato de token inválido' });
    }

    try {
      const decoded = this.jwtService.verify(token);
      req['usu_id'] = decoded; // Adjuntamos el usuario decodificado al request
      next();
    } catch (error) {
      return res.status(401).json({ 
        message: 'Token inválido o expirado',
        error: error.message 
      });
    }
  }
}
```

## Adición de rutas controladas.
En el archivo `src\app.module.ts`
```ts
export class AppModule {
  configure (consumer: MiddlewareConsumer){
    consumer.apply(MetricasMiddleware).forRoutes('*');
    consumer
      .apply(JwtAuthMiddleware)
      .exclude(
        'auth/(.*)',
        'metricas/(.*)',
        { 
          path: 'especialidades/public', // Ruta específica a excluir
          method: RequestMethod.GET 
        }
      )
      .forRoutes(
        UsuariosController,
        EspecialidadesController,
        { path: 'admin/*', method: RequestMethod.ALL }
      );
  }
}
```

## Probar el token 
Crearemos el servicio de creacion de especilidad.

En el archivo `src\especialidades\dto\create-especialidade.dto.ts`
```ts
import { ApiProperty } from "@nestjs/swagger";
import { IsNotEmpty, IsNumber, IsOptional, IsString } from "class-validator";

export class CreateEspecialidadeDto {
    @ApiProperty()
    @IsString()
    @IsNotEmpty()
    public esp_nombre: string;

    @ApiProperty()
    @IsString()
    @IsOptional()
    public esp_observacion: string;

    @ApiProperty()
    @IsNumber()
    public usu_id: number;
}
```

## Modificacion de service
En el archivo `src\especialidades\especialidades.service.ts`
```ts
  async create(createDto: CreateEspecialidadeDto) {
     const maxIdQuery = `
      SELECT COALESCE(MAX(esp_id), 0) as max_id 
      FROM parametricas.especialidades;
    `;

    const maxIdResult = await this.dataSource.query(maxIdQuery);
    const nextId = maxIdResult[0].max_id + 1;

    const query = `
      INSERT INTO parametricas.especialidades (
        esp_id,
        esp_nombre, 
        esp_observacion, 
        usuario_registro
      ) VALUES ($1, $2, $3, $4)
      RETURNING esp_id, esp_nombre, fecha_registro;
    `;
    
    const result = await this.dataSource.query(query, [
      nextId,
      createDto.esp_nombre,
      createDto.esp_observacion || null,
      createDto.usu_id
    ]);
    
    return result[0];
  }
```

## Modificacion de middleware
En el archivo `src\middlewares\autenticacion\autenticacion.middleware.ts`
```ts
try {
      const decoded = this.jwtService.verify(token);
      req.body.usu_id = decoded.usu_id
      next();
    } catch (error) {
      return res.status(401).json({ 
        message: 'Token inválido o expirado',
        error: error.message 
      });
    }
```
ampliar los posibles casos de asignacion

```ts
    try {
      const decoded = this.jwtService.verify(token);
      switch (req.method) {
        case 'POST':
        case 'PUT':
        case 'PATCH':
          req.body.usu_id = decoded.usu_id;
          break;
        case 'GET':
          req.query.usu_id = JSON.stringify(decoded.usu_id);
          break;
        default:
          // Por defecto asignar al request directamente
          req['usu_id'] = decoded.usu_id;
      }
      next();
    } catch (error) {
      return res.status(401).json({ 
        message: 'Token inválido o expirado',
        error: error.message 
      });
    }
```

## Titulo
En el archivo ``
```ts
```

## Titulo
En el archivo ``
```ts
```

## Titulo
En el archivo ``
```ts
```

## Titulo
En el archivo ``
```ts
```

## Titulo
En el archivo ``
```ts
```

## Titulo
En el archivo ``
```ts
```